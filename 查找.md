查找(Find & Search)

## 查找表 -- 查找对象(在哪里查找？)

### 概念
* 查找表(Search Table)是同一类型的数据元素(或记录)的集合。

### 分类
静态查找表(Static Search Table)：查找操作过程中不改变查找表。
* 查找某个特定数据元素是否存在于查找表中。
* 检索某个特定数据元素和各种属性。

动态查找表(Dynamic Search Table)：在查找过程中同时插入不存在的数据元素(`map[]`)，
或在查找过程中删除已经存在的数据元素(`stack\queue`)。
* 查找时插入数据元素。
* 查找时删除数据元素。

## 关键字(Key) -- 查找标示(查找什么？)
### 概念
* 关键字(Key)是数据元素中某个数据项的值，又称为键值。
### 分类
* 主关键字(Primary key)可以唯一地标识一个记录的关键字。
* 次关键字(Secondary Key)识别多个数据元素（或记录）的关键字。

> 查找(Searching)是根据给定的某个值，在查找表中确定一个其关键字等于给定
值的数据元素（或记录）的过程。

## 查找结构 -- 查找方式(怎么查找？)

### 概念
查找结构(Search Struction)面向查找操作的数据结构
### 分类

* 顺序表查找（Sequential Search）又叫线性查找，是最基本的查找技术。它的查找过程是：
 1. 从表中第一个（或最后一个）记录开始，逐个比较记录的关键字和给定值。
 2. 若某个记录的关键字和给定值相等，则查找成功。
 3. 若一直查找到最后一个（或第一个）记录，其关键字都不等于给定值，则查找失败。
* 有序表查找(Order Search)数据已经排好顺序的顺序表。

  |No.|名称|英文名称|分割点|时间复杂度|适用范围|
  |:-:|:-|:-|:-|:-|
  | 1 |折半查找|Binary Search|`mid=(low+high)/2`|`O(logn)`|线性表中的记录必须是关键字有序(通常从小到大)|
  | 2 |插值查找|Interpolation Search|`mid=low+(high-low)*(key-arr[low])/(arr[high]-arr[low])`|`O(logn)`|表长并且关键字分布均匀|
  | 3 |斐波那契查找|Fibonacci Search|`mid=low+F[k-1]-1`|`O(logn)`|只用加减的查找|

C语言标准库提供函数
```
bsearch() // 折半查找
qsort()   // 快速排序
```

Linux
```
lsearch() // 线性查找
hsearch() // hash查找
tsearch() // 二叉树查找
```

C++ STL
```
sort()
search()
```


折半查找与插值查找比较处理

|No.|条件|处理|
|:-:|:-|:-|
| 1 |`arr[mid] == key`|返回`mid`|
| 2 |`arr[mid] >  key`|`high=mid-1`在后部分查找|
| 3 |`arr[mid] <  key`|`low =mid+1`在前部分查找|

斐波那契查找比较处理

|No.|条件|处理|
|:-:|:-|:-|
| 1 |`arr[mid] == key`|返回`mid`|
| 2 |`arr[mid] >  key`|`low=mid+1,k-=2`|
| 3 |`arr[mid] <  key`|`high=mid-1,k-=1`|

low=mid+1说明待查找的元素在[mid+1,high]范围内。
k-=2 说明范围[mid+1,high]内的元素个数为n-(F(k-1))= Fk-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1个。
high=mid-1说明待查找的元素在[low,mid-1]范围内。
k-=1 说明范围[low,mid-1]内的元素个数为F(k-1)-1个。

> 以上三种查找根本区别在于分割点不同，性能各有优劣。

## BST
## AVT--BBST
## 多路查找树(Multi-way Search Tree)


树结构优点：
插入和删除操作所使用的时间非常短

树结构缺点：
* 空间：相对于线性结构占空间较多
* 创建：构造起来比较麻烦
* 维护：对于平衡树，结构修改（增、删）后又需要平衡

多路查找树的每一个结点的孩子数可以多于两个，且每一个结点
处可以存储多个元素。元素之间存在某种特定的排序关系。

特点：
1. 每个结点孩子个数可以`>2`。
2. 每个结点可以存储多个数据元素。

分类：
1. 2-3树
2. 2-3-4树
3. B树(B-树)/B+树

### 2-3树
特点
1.每个节点都具有2个孩子（称之为2节点/2-node）或者3个孩子（称之为3节点/3-node）。
2.一个2节点包含一个元素和两个孩子（或没有孩子）。
3.一个3节点包含两个元素和三个孩子（或没有孩子）。
4.所有叶子都在同一层次。

操作
* 插入
分为三种情况：
1. 空树，插入一个2节点
2. 插入到2节点，变成3节点
3. 插入到3节点，拆分节点
	1. 只包含一个3-node节点
	2. 节点是3-node，父节点是2-node
	3. 节点是3-node，父节点也是3-node
	特例：根节点分裂
* 删除
分为三种情况：
1. 删除3节点的叶子节点，直接删除。
2. 删除2节点的叶子节点
	1. 父节点是2-node，并且右兄弟是3-node。
	2. 父节点是2-node，并且右兄弟是2-node。
	3. 父节点是3-node。
	4. 删除满二叉树的叶子节点。
3. 删除分支节点
* 查找
2-3树的查找和二叉查找树类似，要确定一个树是否属于2-3树，我们首先和其跟节点进行比较，如果相等，则查找成功；否则根据比较的条件，在其左中右子树中递归查找，如果找到的节点为空，则未找到，否则返回。
* 遍历
树的中序遍历

### 2-3-4树

特点
1. 每个节点都具有2个孩子（称之为2节点）或者3个孩子（称之为3节点）或者4个孩子（称之为4节点）。
2. 一个2节点包含一个元素和两个孩子（或没有孩子）。
3. 一个3节点包含两个元素和三个孩子（或没有孩子）。
4. 一个4节点包含三个元素和四个孩子（或没有孩子）
4. 所有叶子都在同一层次。

操作
* 插入
* 删除
* 查找
* 遍历

### B树(B-树)/B+树

B树(B-tree)有时称为B-树，也叫平衡多路查找树。
2-3树与2-3-4树是B树的特例。节点最大的孩子数称为B树的阶(order)。
2-3树的阶是3，2-3-4树的阶是4。

特点：
B树每个结点可以有n个元素和n+1个孩子，减少树的高度，减少树的度，所以可以降低内存读取外存的次数。(对二叉查找树的改进。它的设计思想是，将相关数据尽量集中在一起，以便一次读取多个数据，减少硬盘操作次数）

1.定义任意非叶子结点最多只有M个儿子；且M>2；
2.根结点的儿子数为[2, M]；
3.除根结点以外的非叶子结点的儿子数为[M/2, M]；
4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
5.非叶子结点的关键字个数=指向儿子的指针个数-1；
6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
7.非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
8.所有叶子结点位于同一层；

用途：
为I/O(磁盘或其它存储设备而设计)的一种多叉平衡查找树。

## B+树

B+树不同与B-树的地方：
1. 有n棵子树的节点中包含n个关键字
2. 所有的叶子节点包含全部关键信息，及指向含这些关键字记录的指针
3. 所有分支结点可以看成是索引，节点中仅含有其子树中的最大(或最小)关键字

